<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SecureShare Pro - Ultra-Fast P2P File Transfer</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --primary-light: #818cf8;
      --secondary: #ec4899;
      --secondary-dark: #db2777;
      --success: #10b981;
      --success-dark: #059669;
      --warning: #f59e0b;
      --error: #ef4444;
      --dark: #1f2937;
      --dark-light: #374151;
      --light: #f8fafc;
      --gray: #64748b;
      --gray-light: #94a3b8;
      --border: #e2e8f0;
      --border-light: #f1f5f9;
      --white: #ffffff;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --gradient-secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --gradient-success: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
      --glass-bg: rgba(255, 255, 255, 0.9);
      --glass-border: rgba(255, 255, 255, 0.2);
      --backdrop-blur: blur(20px);
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      --border-radius: 16px;
      --border-radius-lg: 24px;
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
      --spacing-2xl: 48px;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--gradient-primary);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--spacing-lg);
      position: relative;
      overflow-x: hidden;
      color: var(--dark);
      line-height: 1.6;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    .container {
      background: var(--glass-bg);
      backdrop-filter: var(--backdrop-blur);
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-xl);
      border: 1px solid var(--glass-border);
      overflow: hidden;
      width: 100%;
      max-width: 1400px;
      position: relative;
      z-index: 1;
      min-height: 90vh;
      display: flex;
      flex-direction: column;
    }

    .header {
      background: var(--gradient-primary);
      padding: var(--spacing-2xl);
      text-align: center;
      color: var(--white);
      position: relative;
      flex-shrink: 0;
    }

    .header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    }

    .logo {
      font-size: clamp(2rem, 5vw, 3rem);
      font-weight: 800;
      margin-bottom: var(--spacing-sm);
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
      background: linear-gradient(135deg, #fff, #e0e7ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-md);
    }

    .tagline {
      font-size: clamp(1rem, 3vw, 1.25rem);
      opacity: 0.95;
      font-weight: 500;
      margin-bottom: 0;
    }

    .main-content {
      padding: var(--spacing-2xl);
      flex: 1;
      overflow-y: auto;
      position: relative;
    }

    .section {
      display: none;
      animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      height: 100%;
    }

    .section.active {
      display: block;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .role-selector {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: var(--spacing-xl);
      margin-bottom: var(--spacing-xl);
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
    }

    .role-card {
      background: var(--white);
      border: 2px solid var(--border);
      border-radius: var(--border-radius-lg);
      padding: var(--spacing-2xl);
      text-align: center;
      cursor: pointer;
      transition: var(--transition-slow);
      position: relative;
      overflow: hidden;
      transform: translateY(0);
      box-shadow: var(--shadow);
    }

    .role-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
      transition: left 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .role-card:hover::before {
      left: 100%;
    }

    .role-card:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: var(--shadow-xl);
    }

    .role-card.sender:hover {
      border-color: var(--primary);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.05), rgba(99, 102, 241, 0.1));
    }

    .role-card.receiver:hover {
      border-color: var(--secondary);
      background: linear-gradient(135deg, rgba(236, 72, 153, 0.05), rgba(236, 72, 153, 0.1));
    }

    .role-icon {
      font-size: 4rem;
      margin-bottom: var(--spacing-lg);
      display: block;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.1));
    }

    .role-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: var(--spacing-md);
      color: var(--dark);
    }

    .role-desc {
      color: var(--gray);
      font-size: 1rem;
      line-height: 1.6;
    }

    .otp-section {
      text-align: center;
      margin: 0 auto var(--spacing-xl);
      max-width: 600px;
    }

    .otp-label {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--dark);
      margin-bottom: var(--spacing-lg);
    }

    .otp-display {
      background: var(--gradient-primary);
      color: var(--white);
      font-size: clamp(2.5rem, 6vw, 3.5rem);
      font-weight: 800;
      letter-spacing: clamp(8px, 2vw, 12px);
      padding: var(--spacing-xl);
      border-radius: var(--border-radius-lg);
      margin: var(--spacing-lg) 0;
      text-shadow: 0 2px 4px rgba(0,0,0,0.2);
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow-lg);
    }

    .otp-display::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shine 4s infinite;
    }

    @keyframes shine {
      0% { left: -100%; }
      50% { left: 100%; }
      100% { left: 100%; }
    }

    .otp-inputs {
      display: flex;
      justify-content: center;
      gap: clamp(8px, 2vw, 16px);
      margin: var(--spacing-xl) 0;
      flex-wrap: wrap;
    }

    .otp-input {
      width: clamp(48px, 12vw, 64px);
      height: clamp(56px, 14vw, 72px);
      border: 3px solid var(--border);
      border-radius: var(--border-radius);
      text-align: center;
      font-size: clamp(1.25rem, 4vw, 1.8rem);
      font-weight: 700;
      transition: var(--transition);
      background: var(--white);
      color: var(--dark);
    }

    .otp-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
      transform: scale(1.05);
    }

    .btn {
      background: var(--primary);
      color: var(--white);
      border: none;
      padding: clamp(14px, 3vw, 18px) clamp(24px, 6vw, 36px);
      border-radius: var(--border-radius);
      font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      font-weight: 700;
      cursor: pointer;
      transition: var(--transition);
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: var(--shadow);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
      min-height: 48px;
      text-decoration: none;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn:hover:not(:disabled) {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .btn:active:not(:disabled) {
      transform: translateY(0);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    .btn.secondary {
      background: var(--secondary);
    }

    .btn.secondary:hover:not(:disabled) {
      background: var(--secondary-dark);
    }

    .btn.success {
      background: var(--success);
    }

    .btn.success:hover:not(:disabled) {
      background: var(--success-dark);
    }

    .btn.back {
      background: var(--gray);
      margin-right: var(--spacing-md);
    }

    .btn.back:hover:not(:disabled) {
      background: var(--dark-light);
    }

    .btn-group {
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }

    .connected-section {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05));
      border: 2px solid rgba(16, 185, 129, 0.25);
      border-radius: var(--border-radius-lg);
      padding: var(--spacing-xl);
      margin-bottom: var(--spacing-xl);
      text-align: center;
      backdrop-filter: blur(10px);
    }

    .connection-status {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-md);
      color: var(--success);
      font-weight: 700;
      font-size: 1.25rem;
      flex-wrap: wrap;
    }

    .status-dot {
      width: 16px;
      height: 16px;
      background: var(--success);
      border-radius: 50%;
      animation: pulse 2s infinite;
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.6);
      flex-shrink: 0;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.2); }
    }

    .transfer-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: var(--spacing-xl);
      margin-bottom: var(--spacing-xl);
    }

    .transfer-panel {
      background: var(--white);
      border: 2px solid var(--border);
      border-radius: var(--border-radius-lg);
      padding: var(--spacing-xl);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      min-height: 500px;
    }

    .panel-title {
      font-size: 1.375rem;
      font-weight: 700;
      margin-bottom: var(--spacing-lg);
      color: var(--dark);
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      flex-wrap: wrap;
    }

    .chat-area {
      height: 250px;
      border: 2px solid var(--border);
      border-radius: var(--border-radius);
      padding: var(--spacing-lg);
      font-family: 'Inter', monospace;
      font-size: 0.9rem;
      resize: vertical;
      background: var(--light);
      margin-bottom: var(--spacing-lg);
      line-height: 1.6;
      flex-grow: 1;
      min-height: 200px;
    }

    .chat-input {
      display: flex;
      gap: var(--spacing-md);
      align-items: stretch;
    }

    .chat-input input {
      flex: 1;
      padding: var(--spacing-md) var(--spacing-lg);
      border: 2px solid var(--border);
      border-radius: var(--border-radius);
      font-size: 1rem;
      transition: var(--transition);
      min-height: 48px;
    }

    .chat-input input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
    }

    .file-upload {
      border: 3px dashed var(--border);
      border-radius: var(--border-radius-lg);
      padding: var(--spacing-2xl);
      text-align: center;
      margin-bottom: var(--spacing-lg);
      transition: var(--transition);
      cursor: pointer;
      background: linear-gradient(135deg, var(--light), var(--border-light));
      position: relative;
      overflow: hidden;
      min-height: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .file-upload::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 30%, rgba(99, 102, 241, 0.05) 50%, transparent 70%);
      transform: translateX(-100%);
      transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .file-upload:hover::before {
      transform: translateX(100%);
    }

    .file-upload:hover {
      border-color: var(--primary);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(99, 102, 241, 0.12));
      transform: scale(1.01);
      box-shadow: var(--shadow-md);
    }

    .file-upload.drag-over {
      border-color: var(--primary);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(99, 102, 241, 0.2));
      transform: scale(1.02);
      box-shadow: var(--shadow-lg);
    }

    .file-icon {
      font-size: 3.5rem;
      color: var(--primary);
      margin-bottom: var(--spacing-lg);
      filter: drop-shadow(0 4px 8px rgba(99, 102, 241, 0.3));
    }

    .file-upload-text {
      font-weight: 700;
      margin-bottom: var(--spacing-sm);
      font-size: 1.1rem;
      color: var(--dark);
    }

    .file-upload-desc {
      color: var(--gray);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .file-list {
      max-height: 350px;
      overflow-y: auto;
      margin: var(--spacing-lg) 0;
      border: 2px solid var(--border);
      border-radius: var(--border-radius);
      background: var(--white);
      display: none;
    }

    .file-list.show {
      display: block;
    }

    .file-item {
      display: flex;
      align-items: center;
      padding: var(--spacing-md) var(--spacing-lg);
      border-bottom: 1px solid var(--border);
      transition: var(--transition);
      gap: var(--spacing-md);
    }

    .file-item:last-child {
      border-bottom: none;
    }

    .file-item:hover {
      background: rgba(99, 102, 241, 0.05);
    }

    .file-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
      flex-shrink: 0;
    }

    .file-info {
      flex-grow: 1;
      min-width: 0;
    }

    .file-name {
      font-weight: 600;
      color: var(--dark);
      margin-bottom: var(--spacing-xs);
      word-break: break-word;
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .file-size {
      color: var(--gray);
      font-size: 0.875rem;
    }

    .file-remove {
      color: var(--error);
      cursor: pointer;
      padding: var(--spacing-sm);
      border-radius: var(--spacing-sm);
      transition: var(--transition);
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
    }

    .file-remove:hover {
      background: rgba(239, 68, 68, 0.1);
    }

    .file-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
    }

    .progress-container {
      margin: var(--spacing-lg) 0;
      display: none;
    }

    .progress-container.show {
      display: block;
    }

    .progress-bar {
      width: 100%;
      height: 12px;
      background: var(--border);
      border-radius: 6px;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .progress-fill {
      height: 100%;
      background: var(--gradient-primary);
      border-radius: 6px;
      transition: width 0.3s ease;
      position: relative;
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      animation: progress-shine 2s infinite;
    }

    @keyframes progress-shine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .progress-text {
      display: flex;
      justify-content: space-between;
      margin-top: var(--spacing-md);
      font-size: 0.9rem;
      color: var(--gray);
      font-weight: 500;
      gap: var(--spacing-md);
      flex-wrap: wrap;
    }

    .speed-indicator {
      font-size: 0.9rem;
      color: var(--primary);
      font-weight: 600;
    }

    .download-section {
      background: var(--white);
      border: 2px solid var(--border);
      border-radius: var(--border-radius-lg);
      padding: var(--spacing-xl);
      margin-top: var(--spacing-lg);
      display: none;
    }

    .download-section.show {
      display: block;
    }

    .download-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-lg);
      gap: var(--spacing-md);
      flex-wrap: wrap;
    }

    .download-title {
      font-size: 1.375rem;
      font-weight: 700;
      color: var(--dark);
    }

    .download-controls {
      display: flex;
      gap: var(--spacing-md);
      flex-wrap: wrap;
    }

    .download-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: var(--spacing-lg);
    }

    .download-item {
      background: linear-gradient(135deg, var(--light), var(--border-light));
      border: 2px solid var(--border);
      border-radius: var(--border-radius);
      padding: var(--spacing-lg);
      transition: var(--transition);
      position: relative;
      overflow: hidden;
    }

    .download-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(16, 185, 129, 0.1), transparent);
      transition: left 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .download-item:hover::before {
      left: 100%;
    }

    .download-item:hover {
      border-color: var(--success);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .download-item.selected {
      border-color: var(--success);
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05));
    }

    .download-checkbox {
      position: absolute;
      top: var(--spacing-md);
      right: var(--spacing-md);
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .download-file-icon {
      font-size: 2.5rem;
      margin-bottom: var(--spacing-md);
      color: var(--success);
    }

    .download-file-name {
      font-weight: 700;
      color: var(--dark);
      margin-bottom: var(--spacing-sm);
      word-break: break-word;
      line-height: 1.4;
    }

    .download-file-size {
      color: var(--gray);
      font-size: 0.875rem;
      margin-bottom: var(--spacing-md);
    }

    .download-link {
      background: var(--success);
      color: var(--white);
      padding: var(--spacing-md) var(--spacing-lg);
      border-radius: var(--border-radius);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-weight: 600;
      transition: var(--transition);
      width: 100%;
      justify-content: center;
      min-height: 44px;
    }

    .download-link:hover {
      background: var(--success-dark);
      transform: translateY(-1px);
      box-shadow: var(--shadow);
    }

    .bulk-download {
      position: fixed;
      bottom: var(--spacing-xl);
      right: var(--spacing-xl);
      background: var(--success);
      color: var(--white);
      padding: var(--spacing-md) var(--spacing-xl);
      border: none;
      border-radius: 50px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: var(--shadow-lg);
      transition: var(--transition);
      z-index: 1000;
      display: none;
      align-items: center;
      gap: var(--spacing-md);
      font-size: 0.9rem;
      min-height: 56px;
    }

    .bulk-download:hover {
      background: var(--success-dark);
      transform: translateY(-2px);
      box-shadow: var(--shadow-xl);
    }

    .bulk-download.show {
      display: flex;
      animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes slideUp {
      from {
        transform: translateY(100px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .status-message {
      padding: var(--spacing-lg);
      border-radius: var(--border-radius);
      margin: var(--spacing-lg) 0;
      font-weight: 600;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }

    .status-success {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.1));
      border: 2px solid rgba(16, 185, 129, 0.25);
      color: var(--success);
    }

    .status-error {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.1));
      border: 2px solid rgba(239, 68, 68, 0.25);
      color: var(--error);
    }

    .status-info {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(99, 102, 241, 0.1));
      border: 2px solid rgba(99, 102, 241, 0.25);
      color: var(--primary);
    }

    /* Mobile Responsiveness */
    @media (max-width: 1200px) {
      .container {
        max-width: 95vw;
        margin: var(--spacing-md);
      }
      
      .transfer-section {
        grid-template-columns: 1fr;
      }
      
      .download-grid {
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      }
    }

    @media (max-width: 768px) {
      :root {
        --spacing-xs: 3px;
        --spacing-sm: 6px;
        --spacing-md: 12px;
        --spacing-lg: 20px;
        --spacing-xl: 28px;
        --spacing-2xl: 36px;
      }

      body {
        padding: var(--spacing-md);
      }

      .container {
        border-radius: var(--border-radius);
        min-height: 95vh;
        max-width: 100vw;
        margin: 0;
      }

      .header {
        padding: var(--spacing-xl) var(--spacing-lg);
      }

      .main-content {
        padding: var(--spacing-xl) var(--spacing-lg);
      }

      .role-selector {
        grid-template-columns: 1fr;
        gap: var(--spacing-lg);
      }

      .role-card {
        padding: var(--spacing-xl);
      }

      .role-icon {
        font-size: 3rem;
      }

      .otp-inputs {
        justify-content: space-between;
        max-width: 320px;
        margin-left: auto;
        margin-right: auto;
      }

      .btn-group {
        flex-direction: column;
        width: 100%;
      }

      .btn-group .btn {
        width: 100%;
      }

      .transfer-section {
        grid-template-columns: 1fr;
        gap: var(--spacing-lg);
      }

      .transfer-panel {
        padding: var(--spacing-lg);
        min-height: 400px;
      }

      .panel-title {
        font-size: 1.25rem;
      }

      .chat-area {
        height: 200px;
        min-height: 150px;
      }

      .chat-input {
        flex-direction: column;
        gap: var(--spacing-md);
      }

      .chat-input input {
        width: 100%;
      }

      .file-upload {
        padding: var(--spacing-xl) var(--spacing-md);
        min-height: 160px;
      }

      .file-controls {
        grid-template-columns: 1fr;
        gap: var(--spacing-md);
      }

      .download-header {
        flex-direction: column;
        align-items: stretch;
        gap: var(--spacing-md);
      }

      .download-controls {
        justify-content: stretch;
      }

      .download-controls .btn {
        flex: 1;
      }

      .download-grid {
        grid-template-columns: 1fr;
      }

      .bulk-download {
        bottom: var(--spacing-lg);
        right: var(--spacing-lg);
        left: var(--spacing-lg);
        border-radius: var(--border-radius);
        justify-content: center;
      }
    }

    @media (max-width: 480px) {
      .header {
        padding: var(--spacing-lg) var(--spacing-md);
      }

      .main-content {
        padding: var(--spacing-lg) var(--spacing-md);
      }

      .role-card {
        padding: var(--spacing-lg);
      }

      .otp-inputs {
        max-width: 280px;
        gap: var(--spacing-sm);
      }

      .file-upload {
        padding: var(--spacing-lg) var(--spacing-md);
        min-height: 140px;
      }

      .file-icon {
        font-size: 2.5rem;
      }

      .transfer-panel {
        padding: var(--spacing-md);
      }
    }

    /* Performance optimizations */
    .section,
    .role-card,
    .btn,
    .progress-fill,
    .file-item,
    .download-item {
      will-change: transform;
    }

    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--border-light);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--primary-dark);
    }

    /* Accessibility improvements */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* Focus visible for better keyboard navigation */
    .btn:focus-visible,
    .otp-input:focus-visible,
    .chat-input input:focus-visible,
    .file-checkbox:focus-visible,
    .download-checkbox:focus-visible {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }

    /* Loading states */
    .loading {
      position: relative;
      pointer-events: none;
      opacity: 0.7;
    }

    .loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid transparent;
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Enhanced hover states for touch devices */
    @media (hover: none) {
      .role-card:hover,
      .btn:hover,
      .file-item:hover,
      .download-item:hover {
        transform: none;
      }
      
      .role-card:active,
      .btn:active {
        transform: scale(0.98);
      }
    }

    /* Dark mode support (future enhancement) */
    @media (prefers-color-scheme: dark) {
      :root {
        --white: #1f2937;
        --light: #374151;
        --border-light: #4b5563;
        --dark: #f9fafb;
        --gray: #d1d5db;
      }
      
      body::before {
        background: 
          radial-gradient(circle at 20% 80%, rgba(99, 102, 241, 0.2) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(236, 72, 153, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 40% 40%, rgba(16, 185, 129, 0.08) 0%, transparent 50%);
      }
    }

    /* Print styles */
    @media print {
      body {
        background: white;
        color: black;
      }
      
      .container {
        box-shadow: none;
        border: 1px solid #000;
      }
      
      .btn,
      .bulk-download {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">üöÄ SecureShare Pro</div>
      <div class="tagline">Ultra-Fast Peer-to-Peer File Transfer ‚Ä¢ Advanced Security</div>
    </div>

    <div class="main-content">
      <!-- Role Selection -->
      <div id="roleSelect" class="section active">
        <div class="role-selector">
          <div class="role-card sender" onclick="beCreator()">
            <div class="role-icon">üì§</div>
            <div class="role-title">I'm Sending</div>
            <div class="role-desc">Generate a secure code and share multiple files up to 5GB each with ultra-fast transfer speeds</div>
          </div>
          <div class="role-card receiver" onclick="beJoiner()">
            <div class="role-icon">üì•</div>
            <div class="role-title">I'm Receiving</div>
            <div class="role-desc">Enter the secure code to receive files with advanced encryption and blazing fast speeds</div>
          </div>
        </div>
      </div>

      <!-- OTP Generation -->
      <div id="otpSection" class="section">
        <div class="otp-section">
          <div class="otp-label">Share this secure code with the receiver:</div>
          <div class="otp-display" id="otpCode">------</div>
          <div style="color: var(--gray); font-size: 1rem; font-weight: 500; text-align: center; line-height: 1.5;">
            ‚è±Ô∏è Code expires in 10 minutes<br>
            üîí End-to-end encrypted ‚Ä¢ üõ°Ô∏è Zero knowledge transfer
          </div>
        </div>
        <div class="btn-group">
          <button class="btn back" onclick="goBack()">‚Üê Back</button>
          <div class="status-message status-info">
            üîÑ Waiting for receiver to connect securely...
          </div>
        </div>
      </div>

      <!-- OTP Input -->
      <div id="joinSection" class="section">
        <div class="otp-section">
          <div class="otp-label">Enter the 6-digit secure code:</div>
          <div class="otp-inputs">
            <input type="text" maxlength="1" class="otp-input" id="otp0" oninput="nextInput(0)" autocomplete="off">
            <input type="text" maxlength="1" class="otp-input" id="otp1" oninput="nextInput(1)" autocomplete="off">
            <input type="text" maxlength="1" class="otp-input" id="otp2" oninput="nextInput(2)" autocomplete="off">
            <input type="text" maxlength="1" class="otp-input" id="otp3" oninput="nextInput(3)" autocomplete="off">
            <input type="text" maxlength="1" class="otp-input" id="otp4" oninput="nextInput(4)" autocomplete="off">
            <input type="text" maxlength="1" class="otp-input" id="otp5" oninput="nextInput(5)" autocomplete="off">
          </div>
          <div class="btn-group">
            <button class="btn back" onclick="goBack()">‚Üê Back</button>
            <button class="btn secondary" onclick="submitOtp()">üîó Connect Securely</button>
          </div>
          <div id="joinStatus"></div>
        </div>
      </div>

      <!-- Connected State -->
      <div id="connectedSection" class="section">
        <div class="connected-section">
          <div class="connection-status">
            <div class="status-dot"></div>
            <span>üîí Securely Connected ‚Ä¢ Ultra-Fast Mode Active</span>
          </div>
        </div>

        <div class="transfer-section">
          <!-- Chat Panel -->
          <div class="transfer-panel">
            <div class="panel-title">üí¨ Secure Chat</div>
            <textarea id="chat" class="chat-area" placeholder="Secure messages will appear here..." readonly></textarea>
            <div class="chat-input">
              <input id="msgBox" type="text" placeholder="Type a secure message..." onkeypress="handleEnter(event)" autocomplete="off">
              <button class="btn" onclick="sendMsg()">Send</button>
            </div>
          </div>

          <!-- Enhanced File Transfer Panel -->
          <div class="transfer-panel">
            <div class="panel-title">üìÅ Multi-File Transfer Hub</div>
            <div class="file-upload" onclick="document.getElementById('fileInput').click()" 
                 ondrop="handleDrop(event)" ondragover="handleDragOver(event)" 
                 ondragleave="handleDragLeave(event)">
              <div class="file-icon">üìÑ</div>
              <div class="file-upload-text">Click to select or drag multiple files here</div>
              <div class="file-upload-desc">
                ‚ú® Multi-select supported ‚Ä¢ üöÄ Up to 5GB per file<br>
                üì± Any file type ‚Ä¢ üîí End-to-end encrypted
              </div>
            </div>
            <input type="file" id="fileInput" style="display: none;" multiple onchange="handleFileSelect()">
            
            <div id="fileList" class="file-list"></div>
            
            <div class="file-controls">
              <button class="btn success" onclick="selectAllFiles()" id="selectAllBtn" disabled>
                ‚úÖ Select All
              </button>
              <button class="btn" onclick="clearFiles()" id="clearFilesBtn" disabled>
                üóëÔ∏è Clear All
              </button>
            </div>
            
            <button class="btn secondary" onclick="sendFiles()" id="sendFileBtn" style="width: 100%; margin-top: var(--spacing-md);" disabled>
              üì§ Send Selected Files
            </button>
            
            <div id="progressContainer" class="progress-container">
              <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
              </div>
              <div class="progress-text">
                <span id="progressText">Preparing...</span>
                <div>
                  <span id="progressPercent">0%</span>
                  <span id="transferSpeed" class="speed-indicator"></span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Enhanced Download Section -->
        <div id="downloadSection" class="download-section">
          <div class="download-header">
            <div class="download-title">üì• Received Files</div>
            <div class="download-controls">
              <button class="btn success" onclick="selectAllDownloads()">
                ‚úÖ Select All
              </button>
              <button class="btn" onclick="clearAll()" id="clearAllBtn">
                üóëÔ∏è Clear All
              </button>
            </div>
          </div>
          <div id="downloadGrid" class="download-grid"></div>
        </div>

        <div class="btn-group" style="margin-top: var(--spacing-xl);">
          <button class="btn back" onclick="disconnect()">‚ùå Disconnect</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Enhanced Bulk Download Button -->
  <button id="bulkDownloadBtn" class="bulk-download" onclick="downloadSelected()">
    <span>üì•</span>
    <span id="bulkDownloadText">Download Selected (0)</span>
  </button>

  <script>
    // Enhanced P2P File Transfer with Advanced UI/UX
    let ws, pc, dataChannel;
let role;
let receivedChunks = [];
let fileMetadata = null;
let selectedFiles = [];
let isTransferring = false;
let transferStartTime = 0;
let totalBytesTransferred = 0;
let receivedFiles = [];
let selectedDownloads = new Set();
let connectionRetryCount = 0;
let maxRetries = 3;
let isReconnecting = false;
let currentTransferFile = null;

// Enhanced Configuration
const CHUNK_SIZE = 16 * 1024; // Reduced chunk size for better stability
const MAX_FILE_SIZE = 5 * 1024 * 1024 * 1024; 
const MAX_FILE_COUNT = 100;
const MAX_SCTP_BUFFERED = 4 * 1024 * 1024; // Reduced buffer size
const BUFFERED_LOW_THRESHOLD = 1 * 1024 * 1024; // Lower threshold
const CONNECTION_CHECK_INTERVAL = 5000; // Check connection every 5 seconds
const HEARTBEAT_INTERVAL = 30000; // Send heartbeat every 30 seconds

let connectionCheckTimer;
let heartbeatTimer;

// Enhanced UI Functions
function showSection(sectionId) {
  document.querySelectorAll('.section').forEach(section => {
    section.classList.remove('active');
  });
  
  const targetSection = document.getElementById(sectionId);
  if (targetSection) {
    targetSection.classList.add('active');
    // Add loading state briefly for smooth transition
    targetSection.style.opacity = '0';
    requestAnimationFrame(() => {
      targetSection.style.transition = 'opacity 0.3s ease';
      targetSection.style.opacity = '1';
    });
  }
}

function goBack() {
  showSection('roleSelect');
  if (ws) ws.close();
  resetState();
  stopConnectionMonitoring();
}

function resetState() {
  selectedFiles = [];
  selectedDownloads.clear();
  updateFileList();
  updateDownloadSection();
  updateBulkDownloadButton();
  hideProgress();
  isTransferring = false;
  currentTransferFile = null;
  connectionRetryCount = 0;
  isReconnecting = false;
  stopConnectionMonitoring();
}

function startConnectionMonitoring() {
  // Clear existing timers
  stopConnectionMonitoring();
  
  // Connection health check
  connectionCheckTimer = setInterval(() => {
    if (dataChannel && pc) {
      checkConnectionHealth();
    }
  }, CONNECTION_CHECK_INTERVAL);
  
  // Heartbeat
  heartbeatTimer = setInterval(() => {
    if (dataChannel && dataChannel.readyState === 'open' && !isTransferring) {
      try {
        dataChannel.send(JSON.stringify({ type: 'heartbeat', timestamp: Date.now() }));
      } catch (e) {
        console.warn('Heartbeat failed:', e);
      }
    }
  }, HEARTBEAT_INTERVAL);
}

function stopConnectionMonitoring() {
  if (connectionCheckTimer) {
    clearInterval(connectionCheckTimer);
    connectionCheckTimer = null;
  }
  if (heartbeatTimer) {
    clearInterval(heartbeatTimer);
    heartbeatTimer = null;
  }
}

function checkConnectionHealth() {
  if (!pc || !dataChannel) return;
  
  const pcState = pc.connectionState;
  const dcState = dataChannel.readyState;
  
  // Log connection states for debugging
  console.log(`Connection Health - PC: ${pcState}, DC: ${dcState}`);
  
  if (pcState === 'failed' || pcState === 'disconnected' || dcState === 'closed') {
    console.warn('Connection degraded, attempting recovery...');
    if (!isReconnecting && connectionRetryCount < maxRetries) {
      attemptConnectionRecovery();
    }
  }
}

async function attemptConnectionRecovery() {
  if (isReconnecting) return;
  
  isReconnecting = true;
  connectionRetryCount++;
  
  addChatMessage('System', `üîÑ Connection issue detected. Attempting recovery (${connectionRetryCount}/${maxRetries})...`);
  
  try {
    // Wait a bit before attempting recovery
    await sleep(2000);
    
    // Try to restart ICE if peer connection is still alive
    if (pc && pc.connectionState !== 'closed') {
      await pc.restartIce();
      addChatMessage('System', 'üîß ICE restart initiated...');
    }
    
    // Wait for recovery
    await sleep(5000);
    
    if (dataChannel && dataChannel.readyState === 'open') {
      addChatMessage('System', '‚úÖ Connection recovered successfully!');
      connectionRetryCount = 0;
    } else {
      addChatMessage('System', '‚ö†Ô∏è Recovery failed. Connection may be unstable.');
    }
    
  } catch (error) {
    console.error('Recovery attempt failed:', error);
    addChatMessage('System', '‚ùå Connection recovery failed. Please reconnect manually.');
  } finally {
    isReconnecting = false;
  }
}

function beCreator() {
  role = 'creator';
  showLoadingState();
  ws = new WebSocket('wss://filetransferp2p.onrender.com/ws/creator');
  setupWs();
  showSection('otpSection');
}

function beJoiner() {
  role = 'joiner';
  showSection('joinSection');
  setTimeout(() => {
    const firstInput = document.getElementById('otp0');
    if (firstInput) firstInput.focus();
  }, 300);
}

function submitOtp() {
  const otp = Array.from({ length: 6 }, (_, i) => 
    document.getElementById(`otp${i}`).value
  ).join('');
  
  if (otp.length !== 6 || !/^\d{6}$/.test(otp)) {
    showStatus('‚ö†Ô∏è Please enter a valid 6-digit code', 'error', 'joinStatus');
    return;
  }
  
  showLoadingState();
  ws = new WebSocket('wss://filetransferp2p.onrender.com/ws/joiner');
  ws.onopen = () => ws.send(JSON.stringify({ otp }));
  setupWs();
  showStatus('üîÑ Connecting securely...', 'info', 'joinStatus');
}

function setupWs() {
  ws.onmessage = async (event) => {
    try {
      const msg = JSON.parse(event.data);
      hideLoadingState();
      
      switch (msg.type) {
        case 'otp':
          document.getElementById('otpCode').innerText = msg.otp;
          break;
        case 'connected':
          startWebRTC();
          showSection('connectedSection');
          showStatus('‚úÖ Connected! Ultra-fast transfer mode active.', 'success', 'joinStatus');
          break;
        case 'offer':
          await pc.setRemoteDescription(msg);
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify(answer));
          break;
        case 'answer':
          await pc.setRemoteDescription(msg);
          break;
        case 'candidate':
          await pc.addIceCandidate(msg.candidate);
          break;
        case 'error':
          showStatus(`‚ùå ${msg.message}`, 'error', 'joinStatus');
          break;
      }
    } catch (err) {
      console.error('WebSocket message parsing error:', err);
      showStatus('‚ùå Connection error. Please try again.', 'error', 'joinStatus');
    }
  };

  ws.onclose = () => {
    hideLoadingState();
    showStatus('üîå Connection lost. Please try again.', 'error', 'joinStatus');
    stopConnectionMonitoring();
  };
  
  ws.onerror = () => {
    hideLoadingState();
    showStatus('‚ùå Connection failed. Please check your internet and try again.', 'error', 'joinStatus');
    stopConnectionMonitoring();
  };
}

function startWebRTC() {
  pc = new RTCPeerConnection({
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' }
    ],
    iceCandidatePoolSize: 10 // Increase ICE candidate pool
  });

  // Enhanced connection state monitoring
  pc.onconnectionstatechange = () => {
    console.log('PC Connection state:', pc.connectionState);
    if (pc.connectionState === 'connected') {
      addChatMessage('System', 'üîó Peer connection established');
      startConnectionMonitoring();
    } else if (pc.connectionState === 'disconnected') {
      addChatMessage('System', '‚ö†Ô∏è Peer connection disconnected');
      if (!isReconnecting) {
        attemptConnectionRecovery();
      }
    } else if (pc.connectionState === 'failed') {
      addChatMessage('System', '‚ùå Peer connection failed');
      if (!isReconnecting) {
        attemptConnectionRecovery();
      }
    }
  };

  pc.oniceconnectionstatechange = () => {
    console.log('ICE Connection state:', pc.iceConnectionState);
  };

  pc.onicecandidate = (event) => {
    if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ 
        type: 'candidate', 
        candidate: event.candidate 
      }));
    }
  };

  pc.ondatachannel = (event) => {
    dataChannel = event.channel;
    setupDataChannel(dataChannel);
  };

  if (role === 'creator') {
    dataChannel = pc.createDataChannel('data', { 
      ordered: true,
      maxRetransmits: 3
      // Note: Cannot use both maxRetransmits and maxPacketLifeTime simultaneously
    });
    setupDataChannel(dataChannel);
    
    pc.createOffer().then(offer => {
      pc.setLocalDescription(offer);
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(offer));
      }
    }).catch(err => {
      console.error('Offer creation failed:', err);
      addChatMessage('System', '‚ùå Failed to create connection offer');
    });
  }
}

function setupDataChannel(channel) {
  channel.binaryType = 'arraybuffer';
  
  try {
    channel.bufferedAmountLowThreshold = BUFFERED_LOW_THRESHOLD;
  } catch (e) {
    console.warn('bufferedAmountLowThreshold not supported');
  }

  channel.onopen = () => {
    console.log('Data channel established successfully');
    addChatMessage('System', 'üîí Ultra-fast secure connection established!');
    updateFileList();
    enableUI();
    startConnectionMonitoring();
  };

  channel.onmessage = async (e) => {
    try {
      await handleDataMessage(e.data);
    } catch (err) {
      console.error("Message handling error:", err);
      addChatMessage('System', '‚ö†Ô∏è Error processing received data');
    }
  };

  channel.onerror = (error) => {
    console.warn('Data channel error:', error);
    addChatMessage('System', '‚ö†Ô∏è Data channel error detected');
  };

  channel.onclose = () => {
    console.warn('Data channel closed');
    addChatMessage('System', '‚ö†Ô∏è Data channel closed. Attempting recovery...');
    disableUI();
    stopConnectionMonitoring();
    
    // Only attempt recovery if we're not already doing so
    if (!isReconnecting) {
      attemptConnectionRecovery();
    }
  };
}

async function handleDataMessage(data) {
  if (typeof data === 'string') {
    try {
      const obj = JSON.parse(data);
      
      switch (obj.type) {
        case 'file-meta':
          fileMetadata = obj;
          receivedChunks = [];
          transferStartTime = Date.now();
          totalBytesTransferred = 0;
          showProgress(0, `Receiving ${obj.name}`, 0);
          addChatMessage('System', `üì• Receiving: ${obj.name} (${formatFileSize(obj.size)})`);
          break;
        case 'file-complete':
          completeFileReceive();
          break;
        case 'chat':
          addChatMessage('Satya BOT', obj.msg);
          break;
        case 'heartbeat':
          // Respond to heartbeat
          if (dataChannel && dataChannel.readyState === 'open') {
            try {
              dataChannel.send(JSON.stringify({ 
                type: 'heartbeat-response', 
                timestamp: Date.now() 
              }));
            } catch (e) {
              console.warn('Heartbeat response failed:', e);
            }
          }
          break;
        case 'heartbeat-response':
          // Heartbeat acknowledged
          console.log('Heartbeat acknowledged');
          break;
      }
    } catch (err) {
      // If it's not JSON, treat as a regular chat message
      addChatMessage('Satya BOT', data);
    }
  } else {
    // Binary data - file chunk
    if (fileMetadata) {
      receivedChunks.push(data);
      const chunkLength = data instanceof ArrayBuffer ? data.byteLength : (data.size || 0);
      totalBytesTransferred += chunkLength;
      
      const progress = Math.min((totalBytesTransferred / fileMetadata.size) * 100, 100);
      const elapsed = Math.max((Date.now() - transferStartTime) / 1000, 0.001);
      const speed = totalBytesTransferred / elapsed;
      
      showProgress(progress, `Receiving ${fileMetadata.name}`, speed);
    }
  }
}

function completeFileReceive() {
  try {
    const receivedBlob = new Blob(receivedChunks);
    const fileUrl = URL.createObjectURL(receivedBlob);
    
    const fileInfo = {
      name: fileMetadata.name,
      size: fileMetadata.size,
      url: fileUrl,
      id: `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`
    };
    
    receivedFiles.push(fileInfo);
    updateDownloadSection();
    addChatMessage('System', `‚úÖ File received successfully: ${fileMetadata.name}`);
    
    // Show success animation
    showNotification('File received successfully!', 'success');
    
  } catch (err) {
    console.error('Error assembling received file:', err);
    addChatMessage('System', '‚ùå Error processing received file');
    showNotification('Error processing file', 'error');
  } finally {
    hideProgress();
    receivedChunks = [];
    fileMetadata = null;
    totalBytesTransferred = 0;
  }
}

function updateDownloadSection() {
  const downloadSection = document.getElementById('downloadSection');
  const downloadGrid = document.getElementById('downloadGrid');
  
  if (!downloadSection || !downloadGrid) return;

  if (receivedFiles.length === 0) {
    downloadSection.classList.remove('show');
    return;
  }

  downloadSection.classList.add('show');
  downloadGrid.innerHTML = '';

  receivedFiles.forEach(file => {
    const fileItem = document.createElement('div');
    fileItem.className = `download-item ${selectedDownloads.has(file.id) ? 'selected' : ''}`;

    fileItem.innerHTML = `
      <input type="checkbox" class="download-checkbox" 
             data-file-id="${file.id}" 
             ${selectedDownloads.has(file.id) ? 'checked' : ''}>
      <div class="download-file-icon">${getFileIcon(file.name)}</div>
      <div class="download-file-name">${escapeHtml(file.name)}</div>
      <div class="download-file-size">${formatFileSize(file.size)}</div>
      <a href="${file.url}" download="${file.name}" class="download-link">
        üì• Download
      </a>
    `;

    downloadGrid.appendChild(fileItem);
  });

  // Attach event listeners
  downloadGrid.querySelectorAll('.download-checkbox').forEach(checkbox => {
    checkbox.addEventListener('change', handleDownloadCheckboxChange);
  });

  updateBulkDownloadButton();
}

function handleDownloadCheckboxChange(event) {
  const fileId = event.target.getAttribute('data-file-id');
  if (!fileId) return;

  if (event.target.checked) {
    selectedDownloads.add(fileId);
  } else {
    selectedDownloads.delete(fileId);
  }

  updateDownloadSection();
}

function selectAllDownloads() {
  receivedFiles.forEach(file => selectedDownloads.add(file.id));
  updateDownloadSection();
  showNotification('All files selected', 'success');
}

function updateBulkDownloadButton() {
  const bulkBtn = document.getElementById('bulkDownloadBtn');
  const bulkText = document.getElementById('bulkDownloadText');
  
  if (!bulkBtn) return;

  if (selectedDownloads.size > 0) {
    bulkBtn.classList.add('show');
    if (bulkText) {
      bulkText.textContent = `Download Selected (${selectedDownloads.size})`;
    }
  } else {
    bulkBtn.classList.remove('show');
  }
}

function downloadSelected() {
  const selectedFiles = receivedFiles.filter(file => 
    selectedDownloads.has(file.id)
  );

  if (selectedFiles.length === 0) return;

  selectedFiles.forEach((file, index) => {
    setTimeout(() => {
      const link = document.createElement('a');
      link.href = file.url;
      link.download = file.name;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }, index * 100); // Stagger downloads slightly
  });

  showNotification(`Downloading ${selectedFiles.length} files`, 'success');
}

function clearAll() {
  // Clear upload files
  selectedFiles = [];
  selectedDownloads.clear();
  
  // Revoke object URLs to free memory
  receivedFiles.forEach(file => {
    try {
      URL.revokeObjectURL(file.url);
    } catch (e) {
      console.warn('Failed to revoke URL:', e);
    }
  });
  
  receivedFiles = [];
  updateFileList();
  updateDownloadSection();
  updateBulkDownloadButton();
  
  addChatMessage('System', 'üßπ All files cleared. Memory freed for new transfers.');
  showNotification('All files cleared', 'success');
}

function getFileIcon(filename) {
  const ext = filename.split('.').pop().toLowerCase();
  const iconMap = {
    // Documents
    pdf: 'üìÑ', doc: 'üìù', docx: 'üìù', txt: 'üìù', rtf: 'üìù',
    xls: 'üìä', xlsx: 'üìä', csv: 'üìä', ppt: 'üìä', pptx: 'üìä',
    
    // Images
    jpg: 'üñºÔ∏è', jpeg: 'üñºÔ∏è', png: 'üñºÔ∏è', gif: 'üñºÔ∏è', svg: 'üñºÔ∏è',
    bmp: 'üñºÔ∏è', webp: 'üñºÔ∏è', ico: 'üñºÔ∏è', tiff: 'üñºÔ∏è',
    
    // Videos
    mp4: 'üé•', avi: 'üé•', mov: 'üé•', wmv: 'üé•', mkv: 'üé•',
    flv: 'üé•', webm: 'üé•', m4v: 'üé•', '3gp': 'üé•',
    
    // Audio
    mp3: 'üéµ', wav: 'üéµ', flac: 'üéµ', m4a: 'üéµ', aac: 'üéµ',
    ogg: 'üéµ', wma: 'üéµ', opus: 'üéµ',
    
    // Archives
    zip: 'üóúÔ∏è', rar: 'üóúÔ∏è', '7z': 'üóúÔ∏è', tar: 'üóúÔ∏è', gz: 'üóúÔ∏è',
    bz2: 'üóúÔ∏è', xz: 'üóúÔ∏è',
    
    // Code
    js: '‚ö°', html: 'üåê', css: 'üé®', json: 'üìã', xml: 'üìã',
    py: 'üêç', java: '‚òï', cpp: '‚öôÔ∏è', c: '‚öôÔ∏è', php: 'üîß',
    rb: 'üíé', go: 'üîµ', rs: '‚öôÔ∏è', swift: 'üß°',
    
    // Applications
    exe: '‚öôÔ∏è', msi: '‚öôÔ∏è', dmg: 'üíΩ', pkg: 'üì¶', deb: 'üì¶',
    rpm: 'üì¶', appx: 'üì¶'
  };
  
  return iconMap[ext] || 'üìÑ';
}

function addChatMessage(sender, message) {
  const chatArea = document.getElementById('chat');
  if (!chatArea) return;

  const timestamp = new Date().toLocaleTimeString([], { 
    hour: '2-digit', 
    minute: '2-digit' 
  });
  
  const formattedMessage = `[${timestamp}] ${sender}: ${message}\n`;
  chatArea.value += formattedMessage;
  chatArea.scrollTop = chatArea.scrollHeight;

  // Add visual indication for new messages
  if (sender !== 'You') {
    chatArea.style.borderColor = 'var(--success)';
    setTimeout(() => {
      chatArea.style.borderColor = 'var(--border)';
    }, 1000);
  }
}

function sendMsg() {
  const msgBox = document.getElementById('msgBox');
  const message = msgBox?.value?.trim();
  
  if (!message || !dataChannel || dataChannel.readyState !== 'open') {
    if (!message) {
      msgBox?.focus();
    }
    return;
  }

  try {
    dataChannel.send(JSON.stringify({ type: 'chat', msg: message }));
    addChatMessage('You', message);
    if (msgBox) msgBox.value = '';
  } catch (err) {
    console.error('Failed to send message:', err);
    addChatMessage('System', '‚ùå Failed to send message');
  }
}

function handleEnter(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendMsg();
  }
}

function handleFileSelect() {
  const fileInput = document.getElementById('fileInput');
  if (!fileInput?.files) return;

  const newFiles = Array.from(fileInput.files);
  const remainingSlots = Math.max(0, MAX_FILE_COUNT - selectedFiles.length);

  if (newFiles.length > remainingSlots) {
    showNotification(
      `Can only add ${remainingSlots} more files (limit: ${MAX_FILE_COUNT})`, 
      'error'
    );
  }

  const filesToAdd = newFiles.slice(0, remainingSlots);
  let addedCount = 0;
  let skippedCount = 0;

  filesToAdd.forEach(file => {
    if (file.size > MAX_FILE_SIZE) {
      addChatMessage('System', 
        `‚ùå File too large: ${file.name} (max ${formatFileSize(MAX_FILE_SIZE)})`
      );
      skippedCount++;
      return;
    }

    const isDuplicate = selectedFiles.some(f => 
      f.file.name === file.name && f.file.size === file.size
    );

    if (!isDuplicate) {
      selectedFiles.push({
        file,
        selected: true,
        id: `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`
      });
      addedCount++;
    } else {
      skippedCount++;
    }
  });

  updateFileList();

  if (addedCount > 0) {
    showNotification(`Added ${addedCount} files`, 'success');
  }
  if (skippedCount > 0) {
    showNotification(`Skipped ${skippedCount} files (duplicates/too large)`, 'error');
  }

  // Reset file input
  fileInput.value = '';
}

function handleDrop(event) {
  event.preventDefault();
  const fileUpload = event.currentTarget;
  fileUpload?.classList?.remove('drag-over');

  const droppedFiles = Array.from(event.dataTransfer?.files || []);
  if (droppedFiles.length === 0) return;

  // Simulate file input change
  const fileInput = document.getElementById('fileInput');
  if (fileInput) {
    // Create a new FileList-like object
    const dt = new DataTransfer();
    droppedFiles.forEach(file => dt.items.add(file));
    fileInput.files = dt.files;
    handleFileSelect();
  }
}

function handleDragOver(event) {
  event.preventDefault();
  event.currentTarget?.classList?.add('drag-over');
}

function handleDragLeave(event) {
  event.preventDefault();
  event.currentTarget?.classList?.remove('drag-over');
}

function updateFileList() {
  const fileList = document.getElementById('fileList');
  const sendBtn = document.getElementById('sendFileBtn');
  const selectAllBtn = document.getElementById('selectAllBtn');
  const clearBtn = document.getElementById('clearFilesBtn');

  if (!fileList) return;

  if (selectedFiles.length === 0) {
    fileList.classList.remove('show');
    updateButtonStates(sendBtn, selectAllBtn, clearBtn, false);
    return;
  }

  fileList.classList.add('show');
  updateButtonStates(sendBtn, selectAllBtn, clearBtn, true);

  // Clear and rebuild file list
  fileList.innerHTML = '';

  selectedFiles.forEach((entry, index) => {
    const fileItem = document.createElement('div');
    fileItem.className = 'file-item';
    
    fileItem.innerHTML = `
      <input type="checkbox" class="file-checkbox" 
             data-file-idx="${index}" 
             ${entry.selected ? 'checked' : ''}>
      <div class="file-info">
        <div class="file-name">
          ${getFileIcon(entry.file.name)} ${escapeHtml(entry.file.name)}
        </div>
        <div class="file-size">${formatFileSize(entry.file.size)}</div>
      </div>
      <div class="file-remove" data-remove-idx="${index}">üóëÔ∏è</div>
    `;

    fileList.appendChild(fileItem);
  });

  // Attach event listeners
  attachFileListeners(fileList);
  updateSendButton();
}

function attachFileListeners(fileList) {
  fileList.querySelectorAll('.file-checkbox').forEach(checkbox => {
    checkbox.addEventListener('change', handleFileCheckboxChange);
  });

  fileList.querySelectorAll('.file-remove').forEach(removeBtn => {
    removeBtn.addEventListener('click', handleFileRemove);
  });
}

function handleFileCheckboxChange(event) {
  const index = parseInt(event.target.getAttribute('data-file-idx'), 10);
  if (isNaN(index) || !selectedFiles[index]) return;

  selectedFiles[index].selected = event.target.checked;
  updateSendButton();
}

function handleFileRemove(event) {
  const index = parseInt(event.target.getAttribute('data-remove-idx'), 10);
  if (isNaN(index)) return;

  selectedFiles.splice(index, 1);
  updateFileList();
  showNotification('File removed', 'success');
}

function updateButtonStates(sendBtn, selectAllBtn, clearBtn, enabled) {
  if (sendBtn) sendBtn.disabled = !enabled;
  if (selectAllBtn) selectAllBtn.disabled = !enabled;
  if (clearBtn) clearBtn.disabled = !enabled;
}

function updateSendButton() {
  const sendBtn = document.getElementById('sendFileBtn');
  if (!sendBtn) return;

  const selectedCount = selectedFiles.filter(f => f.selected).length;
  const totalSize = selectedFiles
    .filter(f => f.selected)
    .reduce((sum, f) => sum + f.file.size, 0);

  const isChannelReady = dataChannel && dataChannel.readyState === 'open';
  const canSend = selectedCount > 0 && isChannelReady && !isTransferring;

  sendBtn.disabled = !canSend;
  sendBtn.innerHTML = selectedCount > 0 
    ? `üì§ Send ${selectedCount} Files (${formatFileSize(totalSize)})`
    : 'üì§ Send Selected Files';
}

function selectAllFiles() {
  selectedFiles.forEach(file => file.selected = true);
  updateFileList();
  showNotification('All files selected', 'success');
}

function clearFiles() {
  selectedFiles = [];
  updateFileList();
  showNotification('Files cleared', 'success');
}

async function sendFiles() {
  const filesToSend = selectedFiles.filter(f => f.selected);
  
  if (filesToSend.length === 0) {
    showNotification('No files selected', 'error');
    return;
  }

  if (!isDataChannelReady()) {
    showNotification('Connection not ready', 'error');
    return;
  }

  if (isTransferring) return;

  isTransferring = true;
  const sendBtn = document.getElementById('sendFileBtn');
  if (sendBtn) {
    sendBtn.disabled = true;
    sendBtn.classList.add('loading');
  }

  try {
    for (let i = 0; i < filesToSend.length; i++) {
      currentTransferFile = filesToSend[i].file;
      await sendSingleFile(filesToSend[i].file, i + 1, filesToSend.length);
      
      // Check connection health between files
      if (!isDataChannelReady()) {
        throw new Error('Connection lost during transfer');
      }
      
      // Brief pause between files
      if (i < filesToSend.length - 1) {
        await sleep(500); // Increased pause for stability
      }
    }

    addChatMessage('System', 
      `‚úÖ All files sent successfully! (${filesToSend.length} files)`
    );
    showNotification('All files sent successfully!', 'success');

    // Remove sent files from selection
    selectedFiles = selectedFiles.filter(f => !f.selected);
    updateFileList();

  } catch (err) {
    console.error('Error during file transfer:', err);
    addChatMessage('System', '‚ùå Error during transfer: ' + err.message);
    showNotification('Transfer error: ' + err.message, 'error');
    
    // Try to recover connection if it failed
    if (err.message.includes('Connection') || err.message.includes('DataChannel')) {
      attemptConnectionRecovery();
    }
  } finally {
    isTransferring = false;
    currentTransferFile = null;
    if (sendBtn) {
      sendBtn.disabled = false;
      sendBtn.classList.remove('loading');
    }
    hideProgress();
  }
}

function isDataChannelReady() {
  return dataChannel && 
         dataChannel.readyState === 'open' && 
         pc && 
         (pc.connectionState === 'connected' || pc.connectionState === 'connecting');
}

async function sendSingleFile(file, currentFile, totalFiles) {
  if (!isDataChannelReady()) {
    throw new Error('DataChannel not ready');
  }

  const metadata = {
    type: 'file-meta',
    name: file.name,
    size: file.size
  };

  await safeSendWithRetry(JSON.stringify(metadata));

  const fileInfo = totalFiles > 1 
    ? `${file.name} (${currentFile}/${totalFiles})`
    : file.name;

  addChatMessage('You', 
    `üì§ Sending: ${fileInfo} (${formatFileSize(file.size)})`
  );

  transferStartTime = Date.now();
  totalBytesTransferred = 0;
  let offset = 0;

  showProgress(0, `Sending ${fileInfo}`, 0);

  while (offset < file.size) {
    // Check connection before each chunk
    if (!isDataChannelReady()) {
      throw new Error('Connection lost during file transfer');
    }

    const chunkEnd = Math.min(offset + CHUNK_SIZE, file.size);
    const chunk = await file.slice(offset, chunkEnd).arrayBuffer();

    // Wait for buffer to be ready with timeout
    await waitForBufferBelowWithTimeout(MAX_SCTP_BUFFERED, 10000);
    
    // Double-check connection after waiting
    if (!isDataChannelReady()) {
      throw new Error('Connection lost while waiting for buffer');
    }

    await safeSendWithRetry(chunk);

    offset = chunkEnd;
    totalBytesTransferred += chunk.byteLength;

    const progress = (offset / file.size) * 100;
    const elapsed = Math.max((Date.now() - transferStartTime) / 1000, 0.001);
    const speed = totalBytesTransferred / elapsed;

    showProgress(progress, `Sending ${fileInfo}`, speed);
    
    // Small delay every few chunks to prevent overwhelming
    if (offset % (CHUNK_SIZE * 5) === 0) {
      await sleep(10);
    }
  }

  await safeSendWithRetry(JSON.stringify({ type: 'file-complete' }));
  addChatMessage('System', `‚úÖ Sent: ${file.name}`);
}

async function safeSendWithRetry(data, maxRetries = 3) {
  let attempts = 0;
  
  while (attempts < maxRetries) {
    try {
      if (!isDataChannelReady()) {
        throw new Error('DataChannel not ready');
      }
      
      dataChannel.send(data);
      return; // Success, exit function
      
    } catch (err) {
      attempts++;
      console.warn(`Send attempt ${attempts} failed:`, err.message);
      
      if (attempts >= maxRetries) {
        throw new Error(`Failed to send data after ${maxRetries} attempts: ${err.message}`);
      }
      
      // Wait before retry with exponential backoff
      const delay = Math.min(100 * Math.pow(2, attempts - 1), 2000);
      await sleep(delay);
      
      // Check if we can attempt recovery
      if (!isDataChannelReady() && !isReconnecting) {
        addChatMessage('System', `üîÑ Connection issue detected during send, attempting recovery...`);
        await attemptConnectionRecovery();
        
        // Wait a bit more for recovery
        await sleep(1000);
      }
    }
  }
}

function safeSend(data) {
  if (!isDataChannelReady()) {
    throw new Error('DataChannel not ready');
  }
  
  try {
    dataChannel.send(data);
  } catch (err) {
    console.warn('Send failed:', err);
    throw new Error(`Send failed: ${err.message}`);
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function waitForBufferBelowWithTimeout(threshold, timeoutMs = 30000) {
  return new Promise((resolve, reject) => {
    if (!dataChannel) return resolve();
    
    if (dataChannel.bufferedAmount <= threshold) {
      return resolve();
    }

    let resolved = false;
    const startTime = Date.now();
    
    const cleanup = () => {
      if (timeoutId) clearTimeout(timeoutId);
      if (intervalId) clearInterval(intervalId);
      try {
        if (dataChannel) {
          dataChannel.removeEventListener('bufferedamountlow', onLow);
        }
      } catch (e) {}
    };

    const onLow = () => {
      if (resolved) return;
      if (!dataChannel || dataChannel.bufferedAmount <= threshold) {
        resolved = true;
        cleanup();
        resolve();
      }
    };

    // Try to use the proper event first
    try {
      if (dataChannel) {
        dataChannel.addEventListener('bufferedamountlow', onLow);
      }
    } catch (e) {
      // Event not supported
    }

    // Fallback polling with connection checks
    const intervalId = setInterval(() => {
      if (resolved) return;
      
      const elapsed = Date.now() - startTime;
      if (elapsed > timeoutMs) {
        resolved = true;
        cleanup();
        reject(new Error(`Buffer wait timeout after ${timeoutMs}ms`));
        return;
      }
      
      if (!dataChannel) {
        resolved = true;
        cleanup();
        reject(new Error('DataChannel lost during buffer wait'));
        return;
      }
      
      if (!isDataChannelReady()) {
        resolved = true;
        cleanup();
        reject(new Error('Connection lost during buffer wait'));
        return;
      }
      
      if (dataChannel.bufferedAmount <= threshold) {
        resolved = true;
        cleanup();
        resolve();
      }
    }, 50);

    // Timeout
    const timeoutId = setTimeout(() => {
      if (!resolved) {
        resolved = true;
        cleanup();
        reject(new Error(`Buffer wait timeout after ${timeoutMs}ms`));
      }
    }, timeoutMs);
  });
}

async function waitForBufferBelow(threshold) {
  return waitForBufferBelowWithTimeout(threshold, 30000);
}

function showProgress(percent, text, speed = 0) {
  const container = document.getElementById('progressContainer');
  const fill = document.getElementById('progressFill');
  const progressText = document.getElementById('progressText');
  const progressPercent = document.getElementById('progressPercent');
  const transferSpeed = document.getElementById('transferSpeed');

  if (!container) return;

  container.classList.add('show');
  
  if (fill) {
    fill.style.width = Math.min(percent, 100) + '%';
  }
  
  if (progressText) {
    progressText.textContent = text;
  }
  
  if (progressPercent) {
    progressPercent.textContent = Math.round(Math.min(percent, 100)) + '%';
  }
  
  if (transferSpeed) {
    transferSpeed.textContent = speed > 0 ? ` ‚Ä¢ ${formatSpeed(speed)}` : '';
  }
}

function hideProgress() {
  const container = document.getElementById('progressContainer');
  if (container) {
    container.classList.remove('show');
  }
}

function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatSpeed(bytesPerSecond) {
  if (bytesPerSecond === 0) return '0 B/s';
  
  const k = 1024;
  const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
  const i = Math.floor(Math.log(bytesPerSecond) / Math.log(k));
  
  return parseFloat((bytesPerSecond / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function showStatus(message, type, elementId) {
  const element = document.getElementById(elementId);
  if (!element) return;

  element.innerHTML = `
    <div class="status-message status-${type}">
      <span>${message}</span>
    </div>
  `;
}

function showNotification(message, type = 'info') {
  // Create notification element
  const notification = document.createElement('div');
  notification.className = `status-message status-${type}`;
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 10000;
    max-width: 300px;
    animation: slideInRight 0.3s ease;
    box-shadow: var(--shadow-lg);
  `;
  notification.textContent = message;

  document.body.appendChild(notification);

  // Auto-remove after 3 seconds
  setTimeout(() => {
    notification.style.animation = 'slideOutRight 0.3s ease forwards';
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 300);
  }, 3000);
}

function nextInput(index) {
  const current = document.getElementById(`otp${index}`);
  
  if (current && current.value.length === 1 && index < 5) {
    const next = document.getElementById(`otp${index + 1}`);
    if (next) next.focus();
  }

  // Check if all inputs are filled
  const allInputs = Array.from({ length: 6 }, (_, i) => 
    document.getElementById(`otp${i}`)?.value || ''
  );

  if (allInputs.every(val => val.length === 1)) {
    setTimeout(submitOtp, 300);
  }
}

function enableUI() {
  updateFileList();
}

function disableUI() {
  const sendBtn = document.getElementById('sendFileBtn');
  const selectAllBtn = document.getElementById('selectAllBtn');
  const clearBtn = document.getElementById('clearFilesBtn');
  
  if (sendBtn) sendBtn.disabled = true;
  if (selectAllBtn) selectAllBtn.disabled = true;
  if (clearBtn) clearBtn.disabled = true;
}

function showLoadingState() {
  document.body.style.cursor = 'wait';
}

function hideLoadingState() {
  document.body.style.cursor = 'default';
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function disconnect() {
  try {
    stopConnectionMonitoring();
    if (dataChannel) dataChannel.close();
    if (pc) pc.close();
    if (ws) ws.close();
  } catch (e) {
    console.warn('Error during disconnect:', e);
  }

  resetState();
  
  const chatArea = document.getElementById('chat');
  const msgBox = document.getElementById('msgBox');
  
  if (chatArea) chatArea.value = '';
  if (msgBox) msgBox.value = '';
  
  hideProgress();
  showSection('roleSelect');
  showNotification('Disconnected successfully', 'success');
}

// Enhanced OTP input handling
document.addEventListener('DOMContentLoaded', function() {
  // Setup OTP inputs
  for (let i = 0; i < 6; i++) {
    const input = document.getElementById(`otp${i}`);
    if (!input) continue;

    // Handle backspace
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Backspace' && this.value === '' && i > 0) {
        const prev = document.getElementById(`otp${i - 1}`);
        if (prev) {
          prev.focus();
          prev.select();
        }
      }
    });

    // Filter non-numeric input
    input.addEventListener('input', function() {
      this.value = this.value.replace(/[^0-9]/g, '');
      if (this.value.length > 1) {
        this.value = this.value.slice(0, 1);
      }
    });

    // Handle paste
    input.addEventListener('paste', function(e) {
      e.preventDefault();
      const paste = (e.clipboardData || window.clipboardData).getData('text');
      const digits = paste.replace(/[^0-9]/g, '').slice(0, 6);
      
      for (let j = 0; j < digits.length && (i + j) < 6; j++) {
        const targetInput = document.getElementById(`otp${i + j}`);
        if (targetInput) {
          targetInput.value = digits[j];
        }
      }
      
      if (digits.length === 6) {
        setTimeout(submitOtp, 100);
      }
    });
  }

  // Initialize UI state
  resetState();
  
  // Add CSS animations
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
  `;
  document.head.appendChild(style);
});

// Graceful cleanup on page unload
window.addEventListener('beforeunload', function() {
  disconnect();
});

// Handle visibility change (tab switching)
document.addEventListener('visibilitychange', function() {
  if (!document.hidden && dataChannel && dataChannel.readyState === 'open') {
    // Refresh UI when tab becomes visible again
    updateFileList();
    updateDownloadSection();
  }
});

// Performance monitoring (optional)
if (window.performance && window.performance.mark) {
  window.performance.mark('app-loaded');
}

// Expose some functions for debugging (development only)
window.p2pDebug = {
  getConnectionState: () => ({
    ws: ws?.readyState,
    pc: pc?.connectionState,
    dc: dataChannel?.readyState,
    files: selectedFiles.length,
    downloads: receivedFiles.length,
    transferring: isTransferring,
    reconnecting: isReconnecting
  }),
  clearAll,
  disconnect,
  forceRecovery: attemptConnectionRecovery
};

  </script>
</body>
</html>